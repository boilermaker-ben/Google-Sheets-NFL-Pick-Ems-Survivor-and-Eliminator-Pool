<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <!-- Include the SortableJS library for drag-and-drop functionality -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
  <style>
    /* Using styles consistent with your other panels */
    body { font-family: 'Montserrat', Arial, sans-serif; padding: 20px; }
    h2 { color: #013369; margin-top: 0; }
    p { font-size: 14px; color: #333; line-height: 1.6; }
    label { font-weight: 500; }
    select { width: 100px; padding: 8px; border-radius: 4px; border: 1px solid #ccc; }
    .warning { background-color: #fff0f0; border: 1px solid #ffdddd; padding: 15px; border-radius: 8px; margin-top: 20px; }
    .warning strong { color: #D50A0A; }
    .button-row { display: flex; gap: 8px; padding: 12px 8px; }
    .btn { flex: 1; padding: 8px 14px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; font-weight: 600; }
    .btn-primary { background-color: #013369; color: white; }
    .btn-primary:hover { background-color: #2067b3; }
    .btn-secondary { background-color: #D50A0A; color: white; }
    .btn-secondary:hover { background-color: #ff3d3d; }
    .btn-alert { padding: 3px; font-size: 12px; background-color: #ff913d; color: #ffecde; }
    .btn-alert:hover { background-color: #e86705; }
    #matchup-checklist { margin-top: 20px; border-top: 1px solid #eee; padding-top: 15px; }
    .matchup-row { display: flex; align-items: center; padding: 5px; border-radius: 4px; }
    .matchup-row:nth-child(odd) { background-color: #f8f9fa; }
    .matchup-row input { margin-right: 10px; }
    .matchup-info { flex: 1; font-size: 13px; }
    .matchup-details { font-size: 11px; color: #555; margin-left: auto; }
    .switch { position: relative; display: inline-block; width: 36px; height: 20px; transform: scale(0.8); }
    .switch input { opacity: 0; width: 0; height: 0; }
    .switch-small { transform: scale(0.8); }
    .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #999; transition: 0.3s; border-radius: 10px; }
    .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: 0.3s; border-radius: 50%; }
    input:checked+.slider { background-color: #D50A0A; }
    input:checked+.slider:before { transform: translateX(16px); }
    .deselected-row td { color: #999 !important; }
    .deselected-row .team-cell { background-color: #aaa !important; color: #fff !important; border: 1px solid #999; }
    .deselected-row td { color: #999 !important; }
    .deselected-row .team-cell-away { background-color: #aaa !important; color: #fff !important; border: 1px solid #999; }
    .deselected-row .team-cell-home { background-color: #eee !important; color: #aaa !important; border: 1px solid #ccc; }
    #data-status-message { padding: 10px; margin-top: 15px; border-radius: 4px; font-size: 13px; font-weight: 600; text-align: center; }
    #data-status-message.collapsed { height: 0; padding-top: 0; padding-bottom: 0; margin-top: 0; border: none; }
    .status-fresh { background-color: #ecfae7; color: #196901; }
    .status-issue { background-color: #ffecde; color: #ff913d; }
    .status-warn { background-color: #fafae7; color: #595601; }
    .status-stale { background-color: #fff0f0; color: #D50A0A; }
    #loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(255, 255, 255, 0.85); display: flex; justify-content: center; align-items: center; z-index: 100; }
    .spinner { border: 5px solid #f3f3f3; border-top: 5px solid #013369; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .hidden { display: none !important; }
    #matchup-table-container { margin-top: 20px; overflow-y: auto; border: 1px solid #ccc; transition: height 0.3s ease; }
    table { width: 100%; border-collapse: collapse; }
    th, td { padding: 8px; text-align: left; font-size: 12px; border-bottom: 1px solid #ddd; text-align: center; }
    th { background-color: #f2f2f2; font-weight: 600; text-align: center; }
    .weekday-header { background-color: #013369; color: white; font-weight: 700; text-align: left; }
    .weekday-header td { padding-top: 10px; padding-bottom: 10px; text-align: left; }
    tr.disabled td { color: #aaa; background-color: #fafafa; }
    .center-align { text-align: center; }
    .team-cell { font-weight: bold; border-radius: 4px; padding: 4px 6px !important; text-align: center; color: white; }
    .editable-cell { cursor: pointer; position: relative; padding-left: 24px !important; }
    .editable-cell:hover::after { content: '✎';  position: absolute; left: 8px; top: 50%; transform: translateY(-50%); color: #013369; font-weight: bold; }
    .live-input { width: 60px; border: 1px solid #ccc; border-radius: 4px; padding: 4px; font-size: 12px; }
    .invalid-input { border: 2px solid #ff913d !important; background-color: #ffecde; }
    .validation-tooltip { position: relative; }
    .validation-tooltip .tooltip-text { visibility: hidden; width: 180px; background-color: #D50A0A; color: #fff; text-align: center; border-radius: 6px; padding: 5px; position: absolute; z-index: 1; bottom: 125%; left: 50%; margin-left: -90px; opacity: 0; transition: opacity 0.3s; }
    .validation-tooltip:hover .tooltip-text { visibility: visible; opacity: 1; }
    .bonus-cell { text-align: center; }
    .bonus-button { background-color: #ccc; color: #222; border: 1px solid #ccc; border-radius: 5px; font-weight: bold; font-size: 12px; cursor: pointer; width: 45px; padding: 4px 0; transition: background-color 0.2s ease; }
    .bonus-button:hover { border-color: #999; }
    .deselected-row .bonus-button { background-color: #f0f0f0; color: #bbb; border-color: #ddd; cursor: not-allowed; }
    .deselected-row .bonus-button:hover { border-color: #ddd; }    
    tr.bonus-2x { background-color: #fcefc7 !important; }
    tr.bonus-3x { background-color: #fce392 !important; }
    .draggable-row { cursor: move; }
    .sortable-ghost { background-color: #cde4ff; }
    .spread-input-container { display: flex; align-items: center; gap: 5px; }
    .spread-team-selector { display: flex; flex-direction: column; gap: 2px; }
    .spread-team-btn { border: 1px solid #ccc; padding: 2px 5px; border-radius: 4px; font-size: 11px; cursor: pointer; background-color: #f0f0f0; text-align: center; }
    .spread-team-btn.selected { background-color: #013369; color: white; border-color: #013369; font-weight: bold; }
    .deselected-row .spread-team-btn { background-color: #ddd; color: #999; border-color: #ccc; cursor: not-allowed; }
    .deselected-row .spread-team-btn.selected { background-color: #aaa; color: #fff; }
    .spread-value-input { width: 50px; text-align: center; }
    #tiebreaker-container { display: flex; justify-content: space-between; align-items: center; margin-top: 15px; padding: 15px; border: 1px solid #013369; border-radius: 8px; background-color: #f8f9fa; }
    #tiebreaker-container label { font-weight: bold; color: #013369; display: block; margin-bottom: 0; }
    #tiebreaker-input { width: 65px; padding: 8px; border-radius: 4px; border: 1px solid #ccc; font-size: 14px; text-align: center;} 
    .drag-handle { cursor: move; color: #999; user-select: none; text-align: center; font-size: 16px; width: 20px; }
    .drag-handle:hover { color: #333; }
    .day-cell { display: inline-block; padding: 4px 8px; border-radius: 4px; font-weight: 500; font-size: 11px; color: #333; }
    .ats-enabled .team-cell { cursor: pointer; transition: transform 0.1s ease-in-out; }
    .ats-enabled .team-cell:hover { transform: scale(1.05); }
    .team-cell.favored { outline: 3px solid #ff913d; outline-offset: 2px; box-shadow: 0 0 10px rgba(255, 145, 61, 0.7); }
    .favored-team-display { width: 45px; /* Gives space for 3-letter team abbr */ text-align: right; font-weight: bold; font-size: 13px; color: #013369; padding-right: 5px; }
  </style>
</head>
<body>
  <div id="loading-overlay" class="hidden">
    <div class="spinner"></div>
  </div>
  <div id="form-container" style="display: flex; justify-content: space-between; align-items: center;">
    <div>
      <label for="week-select">Select Week:</label>
      <select id="week-select"></select>
    </div>
    <div id="mode-selector">Select:
      <input type="radio" id="modeAll" name="selectionMode" value="all" checked onchange="renderTable()"> <label for="modeAll">All</label>
      <input type="radio" id="modeWeekday" name="selectionMode" value="weekday" onchange="renderTable()"> <label for="modeWeekday">Day</label>
      <input type="radio" id="modeMatchup" name="selectionMode" value="matchup" onchange="renderTable()"> <label for="modeMatchup">Matchup</label>
      <input type="radio" id="modeCustom" name="selectionMode" value="custom" onchange="renderTable()"> <label for="modeCustom">Custom</label>
    </div>
  </div>
  <div id="data-status-message"></div>
  
  <div id="matchup-table-container"></div>

  <div id="tiebreaker-container" class="hidden"></div>

  <div class="button-row">
    <button type="button" class="btn btn-secondary" onclick="google.script.host.close()">Cancel</button>
    <button type="button" class="btn btn-primary" onclick="handleSubmit()">Create Form</button>
  </div>

  <script>
    let hasWarnedAboutOverride = false;
    let apiWeek = null;
    let allMatchups = [];
    let config = {};
    let validitySummary = {};
    let LEAGUE_DATA = {};
    let editedSpreadData = {}; 
    let editedData = false;
    let falseAlarm = false;
    let selectionState = {
      // Stores the checked state for each weekday, e.g., { "Thursday": true, "Friday": false }
      weekdays: {},
      // Stores the checked state for each matchup (using a unique game ID), e.g., { "ARI@LAR": true }
      matchups: {}
    };
    let tiebreakerOverUnder = null;
    let showSpreads, showOverUnder, bonusMultiplierState = {};
    const loader = document.getElementById('loading-overlay');
    let sortableInstance = null;
    
    function showLoader() {
      if (loader) {
        loader.classList.remove('hidden');
      }
    }
    function hideLoader() {
      if (loader) {
        loader.classList.add('hidden');
      }
      
    }
    
    document.addEventListener('DOMContentLoaded', function() {
      showLoader();
      const container = document.getElementById('matchup-table-container');
      container.addEventListener('click', handleTeamSelectClick);
      container.addEventListener('blur', handleInputChange, true);
      container.addEventListener('input', handleInputChange);
      container.addEventListener('click', handleBonusClick);
      google.script.run
        .withSuccessHandler(applyInitialData)
        .withFailureHandler(onDataFetchFailure)
        .fetchFormCreationData();
    });

    function applyInitialData(data) {
      config = data.configuration;
      showSpreads = (config.pickemsInclude && config.pickemsAts) || (config.survivorInclude && config.survivorAts) || (config.eliminatorInclude && config.eliminatorAts);
      showOverUnder = (config.tiebreakerInclude && config.overUnderInclude);
      allMatchups = data.matchupData.available ? data.matchupData.matchups : [];
      validitySummary = data.validitySummary || {};
      apiWeek = data.apiWeek;
      LEAGUE_DATA = data.leagueData || {};
      dayColor = data.dayColor || {};
      dayColorBorder = data.dayColorBorder || {};
      selectionState.weekdays = {};
      selectionState.matchups = {};
      bonusMultiplierState = {};
      const allDays = ["Wednesday", "Thursday", "Friday", "Saturday", "Sunday", "Monday"];
      allDays.forEach(day => selectionState.weekdays[day] = true);
      allMatchups.forEach(game => {
        const gameId = `${game.awayTeam}@${game.homeTeam}`;
        if (config.mnfDouble && (game.dayName === 'Monday' || game.day === 1)) {
          bonusMultiplierState[gameId] = 2;
        } else {
          bonusMultiplierState[gameId] = 1;
        }
        selectionState.matchups[gameId] = true; 
      });
      if (config.hasOwnProperty("matchupCustomization")) {
        if (config.matchupCustomization.hasOwnProperty("days")) {
          if (Object.keys(config.matchupCustomization.days).length > 0) {
            const savedDays = config.matchupCustomization.days;
            const dayMap = { "includeWed": "Wednesday", "includeThu": "Thursday", "includeFri": "Friday", "includeSat": "Saturday", "includeSun": "Sunday", "includeMon": "Monday" };
            for (const key in savedDays) {
                if (dayMap[key]) {
                    selectionState.weekdays[dayMap[key]] = savedDays[key];
                }
            }
          }
        }
      }

      const weekSelect = document.getElementById('week-select');
      weekSelect.addEventListener('change', updateDisplayForWeek);
      const uniqueWeeks = [...new Set(allMatchups.map(m => m.week))].sort((a, b) => a - b);
      
      uniqueWeeks.forEach(weekNum => {
        const option = document.createElement('option');
        option.value = weekNum;
        option.textContent = `Week ${weekNum}`;
        weekSelect.appendChild(option);
      });
      
      weekSelect.addEventListener('change', renderTable);
      
      // Set initial radio button state based on saved config
      if (!config.customizeMatchups) {
        document.getElementById('modeAll').checked = true;
      } else if (config.matchupCustomization && config.matchupCustomization.mode === 'weekday') {
        document.getElementById('modeWeekday').checked = true;
      } else if (config.matchupCustomization && config.matchupCustomization.mode === 'matchup') {
        document.getElementById('modeMatchup').checked = true;
      }

      // Initial render
      updateDisplayForWeek();
      hideLoader();
    }

    function updateDisplayForWeek() {
        bonusMultiplierState = {};
        hasWarnedAboutOverride = false;
        const selectedWeek = document.getElementById('week-select').value;
        renderStatusMessage(selectedWeek);
        renderTable(selectedWeek);
        // Dynamic height adjustment should happen after rendering
        adjustDialogHeight(selectedWeek);
    }

    function renderStatusMessage(week) {
      const selectionMode = document.querySelector('input[name="selectionMode"]:checked').value;
      const statusMessageDiv = document.getElementById('data-status-message');
      const weekMatchups = allMatchups.filter(m => m.week == week);

      // Use classList.toggle for a clean way to show/hide the element.
      statusMessageDiv.classList.toggle('collapsed', !showSpreads);

      // If it's not relevant, we don't need to do any more work.
      if (!showSpreads) {
          return;
      }
      
      // Check for data completeness
      let allSpreadsFilled = true;

      weekMatchups.forEach(game => {
          const gameId = `${game.awayTeam}@${game.homeTeam}`;
          const spread = editedSpreadData[gameId]?.spread ?? game.spread;
          if (selectionMode === 'matchup' && selectionState.matchups[gameId]) {
            if (!spread || spread === 'N/A') allSpreadsFilled = false;
          } else if (selectionMode === 'weekday' && selectionState.weekdays[game.day]) {
            if (!spread || spread === 'N/A') allSpreadsFilled = false;
          }
      });

      const weekValidity = validitySummary[week];
      let addedSpreadRefreshButton = false;

      if (!weekValidity) {
        statusMessageDiv.innerHTML = '';
        statusMessageDiv.className = '';
        return;
      }

      const timeFetched = new Date(weekValidity.timeFetched);
      const now = new Date();
      const hoursAgo = (now - timeFetched) / (3600 * 1000);
      const dateStr = timeFetched.toLocaleDateString();
      const timeStr = timeFetched.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      let message = '';
      let statusClass = 'status-fresh';        
      if (weekValidity.timeFetched === 'ERROR') {
        message = `❌ <strong>ERROR</strong>: Inconsistent data fetch times detected for this week.`;
        statusClass = 'status-stale';
      } else if (!weekValidity.spreads && (config.pickemsAts || config.survivorAts)) {
        message = `✏️ <strong>ISSUE</strong>: Spreads are missing for one or more games this week.`;
        statusClass = 'status-issue';
      } else if (hoursAgo > 24) {
        message = `⚠️ ${weekValidity.auto ? 'Automatic s' : 'S'}pread data from ${dateStr} at ${timeStr} (over ${hoursAgo > 48 ? Math.floor(hoursAgo/24) + ' days' : Math.floor(hoursAgo) + ' hours'} ago). `;
        if (week == apiWeek) {
          message += `  <button type="button" class="btn btn-alert" id="fetch-spreads-btn">Update Now</button>`;
          addedSpreadRefreshButton = true;
        }
        statusClass = 'status-warn';
      } else if (showSpreads || showOverUnder) {
        message = `✅ Spread data complete!`;
        if (weekValidity.auto) message += ` (automatically captured on ${dateStr} at ${timeStr})`;
      }
      statusMessageDiv.innerHTML = message;
      statusMessageDiv.className = statusClass;
      if (addedSpreadRefreshButton) document.getElementById('fetch-spreads-btn').addEventListener('click', handleFetchSpreadsClick);
    }

    function formatTime(hour, minute) {
        // [THE FIX] Check for invalid data at the beginning.
        if (hour === null || hour === '' || isNaN(hour) || minute === null || isNaN(minute)) {
            return 'TBD'; // Return a safe default
        }
        const h = parseInt(hour, 10);
        const m = String(minute).padStart(2, '0');
        const ampm = h >= 12 ? 'PM' : 'AM';
        const formattedHour = h % 12 || 12; // Convert 0 to 12 for 12 AM
        return `${formattedHour}:${m} ${ampm}`;
    }

    function renderTable() {
      scrubInvalidatedData();

      const selectedWeek = document.getElementById('week-select').value;
      const selectionMode = document.querySelector('input[name="selectionMode"]:checked').value;
      const container = document.getElementById('matchup-table-container');
      const statusMessageDiv = document.getElementById('data-status-message');
      const weekValidity = validitySummary[selectedWeek] || {};
      
      const weekMatchups = allMatchups.filter(m => m.week == selectedWeek);

      const showBonus = config.bonusInclude;
      
      const isCustomMode = selectionMode === 'custom';

      let hasAnySpreadData = false;
      let timeFetched = null;
      if (weekMatchups.length > 0) {
        // Find the first valid timeFetched value for the week
        const firstGameWithData = weekMatchups.find(g => g.timeFetched);
        if (firstGameWithData) {
          timeFetched = new Date(firstGameWithData.timeFetched);
          hasAnySpreadData = true;
        }
      }

      if (weekMatchups.length === 0) {
        container.innerHTML = '<p style="text-align: center; padding: 20px;">No matchups found for this week.</p>';
        google.script.host.setHeight(250); // Set a small, fixed height
        return;
      }
      const firstColumnHeader = selectionMode === 'matchup' ? 'Include<th>Day</th>' : 'Day';

      let headerHtml = '<tr>';
      if (isCustomMode) {
        headerHtml += `<th></th><th>Include</th><th>Day</th><th>Time</th>`;
      } else {
        headerHtml += `<th>${selectionMode === 'all' ? '' : 'Include'}</th><th>Time</th>`;
      }
      headerHtml += `<th>Away</th><th>Home</th>
        ${showSpreads ? '<th>Spread</th>' : ''}
        ${showBonus ? '<th>Bonus</th>' : ''}
      </tr>`;
      
      let tableHtml = `
        <table id="matchup-table">
          <thead>${headerHtml}</thead>
          <tbody id="matchup-table-body">
      `;
      
      // ALL AND WEEKDAY SELECTION MODE UI CREATION
      const gamesByDay = weekMatchups.reduce((acc, game) => {
        const day = game.dayName || 'TBD';
        if (!acc[day]) acc[day] = [];
        acc[day].push(game);
        return acc;
      }, {});
     
      const renderGameRow = (game) => {
        const gameId = `${game.awayTeam}@${game.homeTeam}`;
        const currentMultiplier = bonusMultiplierState[gameId] || 1;
        const isMatchupChecked = selectionState.matchups[gameId] !== false;
        let firstCellContent = '';
        const isDayChecked = selectionState.weekdays[game.dayName] !== false;

        if (selectionMode === 'matchup' || isCustomMode) {
          firstCellContent = `<label class="switch switch-small"><input type="checkbox" name="matchupToggle" value="${gameId}" ${isMatchupChecked ? 'checked' : ''}><span class="slider"></span></label>`;
        }

        const isRowEnabled = (selectionMode !== 'weekday' || isDayChecked) && (selectionMode !== 'matchup' || isMatchupChecked) && (selectionMode !== 'custom' || isMatchupChecked);
        let rowClass = isRowEnabled ? '' : 'deselected-row';
        if (showSpreads) rowClass += ' ats-enabled';
        // if (isCustomMode) rowClass += ' draggable-row';
        if (showBonus && currentMultiplier === 2) rowClass += ' bonus-2x';
        else if (showBonus && currentMultiplier === 3) rowClass += ' bonus-3x';

        const awayData = LEAGUE_DATA[game.awayTeam] || { colors: [] };
        const homeData = LEAGUE_DATA[game.homeTeam] || { colors: [] };
        const homeBg = (homeData.colors[1]?.toUpperCase() === '#FFFFFF') ? homeData.colors[2] : homeData.colors[1];
        
        let spreadCellContent = '';
        if (showSpreads) {
          const initialSpreadValue = game.spread || 'N/A'; // Get original spread
          const isInitialDataValid = isValidSpread(initialSpreadValue, game.awayTeam, game.homeTeam);

          const spreadValue = editedSpreadData[gameId]?.spread ?? initialSpreadValue;
          const { favoredTeam, points } = parseSpread(spreadValue, game.awayTeam, game.homeTeam);
          
          spreadCellContent = `
            <td class="spread-input-cell" data-game-id="${gameId}">
              <div class="spread-input-container">
                <span class="favored-team-display">${favoredTeam || ''}</span>
                <input type="number" class="spread-value-input live-input ${!isInitialDataValid ? 'invalid-input' : ''}" 
                        value="${points || ''}" step="0.5" min="-20.5" max="0" placeholder="-3.5" data-type="spread-value">
              </div>
            </td>`;
          }

        const bonusCellHtml = showBonus ? `<td class="bonus-cell"><button type="button" class="bonus-button" data-game-id="${gameId}">${currentMultiplier}x</button></td>` : '';

        let dragHandleCell = '';
        let dayAndTimeCells = `<td>${formatTime(game.hour, game.minute)}</td>`;
        if (isCustomMode) {
          dragHandleCell = `<td><div class="drag-handle">☰</div></td>`;
          
          const bgColor = dayColor[game.dayName] || '#f0f0f0';
          const borderColor = dayColorBorder[game.dayName] || '#ccc';
          const dayCellHtml = `<span class="day-cell" style="background-color: ${bgColor}; border: 1px solid ${borderColor};">${game.dayName}</span>`;

          dayAndTimeCells = `<td>${dayCellHtml}</td><td>${formatTime(game.hour, game.minute)}</td>`;
        }
        
        const spreadValue = editedSpreadData[gameId]?.spread ?? (game.spread || 'N/A');
        const { favoredTeam } = parseSpread(spreadValue, game.awayTeam, game.homeTeam);
        
        return `
          <tr id="match-row-${gameId}" class="${rowClass}" data-day="${game.dayName}" data-game-id="${gameId}" data-away-team="${game.awayTeam}" data-home-team="${game.homeTeam}">
            ${dragHandleCell}
            <td>${firstCellContent}</td>
            ${dayAndTimeCells}
            <td>
              <span class="team-cell team-cell-away ${favoredTeam === game.awayTeam ? 'favored' : ''}" data-team-abbr="${game.awayTeam}"
                    style="background-color: ${awayData.colors[0] || '#888'}; color: ${awayData.colors[1] || '#fff'};">
                ${game.awayTeam}${!config.hideEmojis ? awayData.mascot : ''}
              </span>
            </td>
            <td>
              <span class="team-cell team-cell-home ${favoredTeam === game.homeTeam ? 'favored' : ''}" data-team-abbr="${game.homeTeam}"
                    style="background-color: ${homeBg || '#888'}; color: ${homeData.colors[0] || '#fff'};">
                ${game.homeTeam}${!config.hideEmojis ? homeData.mascot : ''}
              </span>
            </td>
            ${spreadCellContent}
            ${bonusCellHtml}
          </tr>`;
      }
      
      if (isCustomMode) {
        weekMatchups.forEach(game => tableHtml += renderGameRow(game));
      } else {
        for (const day in gamesByDay) {
          const isDayChecked = selectionState.weekdays[day] !== false;
          let headerContent = (selectionMode === 'weekday') 
            ? `<label class="switch"><input type="checkbox" name="weekdayToggle" value="${day}" ${isDayChecked ? 'checked' : ''}><span class="slider"></span></label> <label style="margin-left: 5px;">${day}</label>`
            : day;
          
          tableHtml += `<tr class="weekday-header"><td colspan="7">${headerContent}</td></tr>`;
          gamesByDay[day].forEach(game => tableHtml += renderGameRow(game));
        }
      }

      tableHtml += '</tbody></table>';
      container.innerHTML = tableHtml;

      // WEEKDAY MODE LISTENER
      document.querySelectorAll('input[name="weekdayToggle"]').forEach(toggle => {
        toggle.addEventListener('change', (e) => {
          selectionState.weekdays[e.target.value] = e.target.checked;
          document.querySelectorAll(`tr[data-day="${e.target.value}"]`).forEach(row => updateRowVisuals(row, e.target.checked));
          renderTiebreakerOverUnder(); // Update tiebreaker on filter change
        });
      });
      
      // MATCHUP MODE LISTENER
      document.querySelectorAll('input[name="matchupToggle"]').forEach(toggle => {
        toggle.addEventListener('change', (e) => {
          selectionState.matchups[e.target.value] = e.target.checked;
          const row = document.getElementById(`match-row-${e.target.value}`);
          if (row) updateRowVisuals(row, e.target.checked);
          renderTiebreakerOverUnder(); // Update tiebreaker on filter change
        });
      });

      // MODIFICATION: Initialize Sortable.js if in custom mode
      if (isCustomMode) {
        const tableBody = document.getElementById('matchup-table-body');
        sortableInstance = new Sortable(tableBody, {
            animation: 150,
            ghostClass: 'sortable-ghost',
            handle: '.drag-handle',
            onEnd: function() {
              renderTiebreakerOverUnder();
            }
        });
      }
      renderTiebreakerOverUnder();

    }
    
    /**
     * Render the single over/under tiebreaker input.
     */
    function renderTiebreakerOverUnder() {
      const container = document.getElementById('tiebreaker-container');
      if (!showOverUnder) {
        container.classList.add('hidden');
        container.innerHTML = '';
        return;
      }

      const includedGames = getIncludedGames(); // Helper to get currently visible games
      if (includedGames.length === 0) {
        container.classList.add('hidden');
        container.innerHTML = '';
        return;
      }

      const lastGame = includedGames[includedGames.length - 1];
      const lastGameId = `${lastGame.awayTeam}@${lastGame.homeTeam}`;

      // Use the saved tiebreaker value if it exists, otherwise get from game data
      const overUnderValue = (tiebreakerOverUnder !== null) ? tiebreakerOverUnder : (lastGame.overUnder || '');;
      
      const isValid = isValidOverUnder(overUnderValue);

      let html = `
        <label for="tiebreaker-input">Tiebreaker Over/Under for ${lastGame.awayTeam} @ ${lastGame.homeTeam}</label>
        <input type="number" id="tiebreaker-input" class="live-input ${!isValid ? 'invalid-input' : ''}" 
          value="${overUnderValue}" placeholder="e.g., 48.5" step="0.5">
      `;
      container.innerHTML = html;
      container.classList.remove('hidden');

      // Add event listener to the new input
      document.getElementById('tiebreaker-input').addEventListener('input', (e) => {
        const value = e.target.value;
        tiebreakerOverUnder = value; // Update state
        const isValid = isValidOverUnder(value);
        e.target.classList.toggle('invalid-input', !isValid && value !== '');
      });
    }
    
    function adjustDialogHeight(selectedWeek) {
      const weekMatchups = allMatchups.filter(m => m.week == selectedWeek);
      const baseHeight = document.documentElement.scrollHeight;
      const heightPerRow = 35; 
      const calculatedHeight = Math.min(baseHeight + (weekMatchups.length * heightPerRow), 800);
      google.script.host.setHeight(calculatedHeight);
    }

    /**
     * Handler for clicking on the main team cells to select a favorite.
     */
    function handleTeamSelectClick(e) {
      const teamCell = e.target.closest('.ats-enabled .team-cell');
      if (!teamCell) return;

      const row = teamCell.closest('tr');
      checkAndWarnAboutOverride(row.dataset.gameId);
      const sibling = row.querySelector(teamCell.classList.contains('team-cell-away') ? '.team-cell-home' : '.team-cell-away');
      const valueInput = row.querySelector('.spread-value-input');

      if (teamCell.classList.contains('favored')) {
        teamCell.classList.remove('favored');
      } else {
        teamCell.classList.add('favored');
        if (sibling) sibling.classList.remove('favored');

        if (valueInput && (valueInput.value === '' || parseFloat(valueInput.value) === 0)) {
          valueInput.value = -0.5;
        }
      }
      updateSpreadFromRowState(row);
    }

    /**
     * Central function to read a row's state and update the spread data.
     */
    function updateSpreadFromRowState(row) {
      if (!row) return;
      const gameId = row.dataset.gameId;
      const homeTeam = row.dataset.homeTeam;
      const awayTeam = row.dataset.awayTeam;

      const favoredCell = row.querySelector('.team-cell.favored');
      const valueInput = row.querySelector('.spread-value-input');
      const favoredDisplay = row.querySelector('.favored-team-display');

      let num = parseFloat(valueInput.value);

      if (isNaN(num)) {
        num = '';
      } else {
        if (num > 0) num = 0;
        if (num < -20.5) num = -20.5;

        // If the number is a whole number (and not 0), snap it to the nearest .5
        if (num !== 0 && num % 1 === 0) {
           num = num - 0.5;
        }
      }
      
      // Only update the input if our logic has corrected it
      if (valueInput.value !== num.toString()) {
        valueInput.value = num;
      }

      const favoredTeam = favoredCell ? favoredCell.dataset.teamAbbr : null;
      const points = valueInput.value;
      
      let spreadString = '';
      if (parseFloat(points) === 0) {
        spreadString = 'PK';
        favoredDisplay.textContent = 'PK';
        if (favoredCell) favoredCell.classList.remove('favored');
      } else if (favoredTeam && points) {
        // The 'points' value is already negative, so we just append it.
        spreadString = `${favoredTeam} ${points}`;
        favoredDisplay.textContent = favoredTeam;
      } else {
        favoredDisplay.textContent = '';
      }

      if (!editedSpreadData[gameId]) editedSpreadData[gameId] = {};
      editedSpreadData[gameId].spread = spreadString;
      if (!editedData) editedData = true;

      const isValid = isValidSpread(spreadString, awayTeam, homeTeam);
      // The box is invalid if a valid string hasn't been formed yet.
      valueInput.classList.toggle('invalid-input', !isValid);
      renderStatusMessage(document.getElementById('week-select').value);
    }

    /**
     * Helper to show a one-time alert when overriding existing valid data.
    */
    function checkAndWarnAboutOverride(gameId) {
      if (hasWarnedAboutOverride || !showSpreads) return;

      const weekMatchups = allMatchups.filter(m => m.week == document.getElementById('week-select').value);
      const originalGame = weekMatchups.find(g => `${g.awayTeam}@${g.homeTeam}` === gameId);

      // Check if the original data existed and was valid
      if (originalGame && isValidSpread(originalGame.spread, originalGame.awayTeam, originalGame.homeTeam)) {
        alert("⚠️ ALERT: You are about to manually override pre-populated spread data. Your changes will be saved for this form.");
        hasWarnedAboutOverride = true; // Set flag so it only shows once per week
      }
    }

    /**
     * Handler for the spread component (team clicks).
     */
    function handleSpreadComponentClick(e) {
      const btn = e.target.closest('.spread-team-btn');
      if (!btn) return;
      
      const container = btn.closest('.spread-team-selector');
      // Deselect sibling
      const otherBtn = container.querySelector(btn.dataset.teamType === 'away' ? '.spread-team-btn[data-team-type="home"]' : '.spread-team-btn[data-team-type="away"]');

      if (btn.classList.contains('selected')) {
        // If clicking an already selected button, deselect it
        btn.classList.remove('selected');
      } else {
        // Select the clicked button and deselect the other
        btn.classList.add('selected');
        if (otherBtn) otherBtn.classList.remove('selected');
      }

      // Trigger the main input change handler to save the data
      handleInputChange({ target: btn });
    }

    function handleLiveInputChange(e) {
        const input = e.target;
        if (!input.classList.contains('live-input')) return;

        const dataType = input.dataset.type;
        const gameId = input.dataset.gameId;
        const newValue = input.value.trim();

        if (!editedSpreadData[gameId]) {
          editedSpreadData[gameId] = {};
        }
        editedSpreadData[gameId][dataType] = newValue;
    }
    
    /**
     * Input handler that just calls the state update function.
     */
    function handleInputChange(e) {
      const input = e.target;
      const row = input.closest('tr');
      if (!row) return;

      // Check if the change happened in the spread value input
      if (input.matches('.spread-value-input')) {
        checkAndWarnAboutOverride(row.dataset.gameId); 
        updateSpreadFromRowState(row);
      }
    }
    
    /**
     * Helper function to parse a spread string into components.
     */
    function parseSpread(spreadString, awayTeam, homeTeam) {
      if (!spreadString || typeof spreadString !== 'string' || spreadString === 'N/A') {
        return { favoredTeam: null, points: null };
      }
      const upperVal = spreadString.toUpperCase();
      if (['PK', 'PUSH', 'EVEN', '0'].includes(upperVal)) {
        return { favoredTeam: null, points: '0' };
      }

      // Regex now makes the hyphen optional to catch both "3.5" and "-3.5"
      const spreadRegex = new RegExp(`^(${awayTeam}|${homeTeam})\\s(-?)(\\d*\\.?\\d+)$`, 'i');
      const match = spreadString.match(spreadRegex);

      if (match) {
        const team = match[1];
        let pointValue = parseFloat(match[3]);
        
        // If the number was positive in the source, make it negative.
        if (pointValue > 0) {
          pointValue = -pointValue;
        }

        return { favoredTeam: team, points: pointValue.toString() };
      }
      return { favoredTeam: null, points: null };
    }

    function handleBonusClick(e) {
      const button = e.target.closest('.bonus-button');
      if (!button) return;
      const row = e.target.closest('tr');
      if (row.matches('.deselected-row')) {
        row.classList.remove('bonus-2x', 'bonus-3x');
        return;
      }
      
      const gameId = button.dataset.gameId;
      
      // Cycle through the values: 1 -> 2 -> 3 -> 1
      let currentMultiplier = bonusMultiplierState[gameId] || 1;
      let nextMultiplier = currentMultiplier >= 3 ? 1 : currentMultiplier + 1;
      
      // Update the state
      bonusMultiplierState[gameId] = nextMultiplier;
      
      // Update the UI
      button.textContent = `${nextMultiplier}x`;
      
      row.classList.remove('bonus-2x', 'bonus-3x');
      if (nextMultiplier === 2) {
        row.classList.add('bonus-2x');
      } else if (nextMultiplier === 3) {
        row.classList.add('bonus-3x');
      }
    }
    
    /**
     * Handles the click on the "Fetch Latest Spreads" button.
     */
    function handleFetchSpreadsClick() {
      const selectedWeek = document.getElementById('week-select').value;
      
      // Show the loader with a specific message
      showLoader();
      google.script.run
        .withSuccessHandler(onFetchSpreadsSuccess)
        .withFailureHandler(onDataFetchFailure) // Can reuse the general failure handler
        .fetchLatestSpreadsForWeek(selectedWeek);
    }

    /**
     * Handles the successful return from the spread fetch.
     * It then re-triggers the initial data load to refresh the entire panel.
     */
    function onFetchSpreadsSuccess(response) {
      console.log(response.message);
      hideLoader();
      // This is the key: after a successful fetch, we re-run the original data load
      // to get the fresh data and automatically re-render the entire UI.
      google.script.run
        .withSuccessHandler(applyInitialData)
        .withFailureHandler(onDataFetchFailure)
        .fetchFormCreationData();
    }

    /**
     * Validates a spread value.
     * Allowed formats: "TEAM -7.5", "TEAM +3", "PK", "PUSH", "EVEN".
     * @param {string} value The input string to validate.
     * @param {string} awayTeam The away team abbreviation.
     * @param {string} homeTeam The home team abbreviation.
     * @returns {boolean} True if the format is valid.
     */
    function isValidSpread(value, awayTeam, homeTeam) {
      if (!value) return false; // An empty value is not valid
      const upperVal = value.toUpperCase();
      if (['PK', 'PUSH', 'EVEN'].includes(upperVal)) return true;

      // Check for the "TEAM -X.5" format
      const spreadRegex = new RegExp(`^(${awayTeam}|${homeTeam})\\s-(\\d+(\\.5)?)$`, 'i');
      return spreadRegex.test(value);
    }

    /**
     * Validates an Over/Under value.
     * Must be a number between 0.5 and 99.5 and end in .5.
     * @param {string} value The input string to validate.
     * @returns {boolean} True if the format is valid.
     */
    function isValidOverUnder(value) {
      if (value === null || value === '') return false; // Must not be empty
      const num = parseFloat(value);
      if (isNaN(num)) return false;
      if (num < 0.5 || num > 99.5) return false;
      // Check if it ends in .5 or .0
      return (num * 2) % 1 === 0;
    }

    /**
     * Validates that all required data is present for selected games
     * @param {Array} includedGameIds - Array of game IDs that are selected for inclusion
     * @param {Array} weekMatchups - All matchups for the selected week
     * @returns {Object} - {isValid: boolean, message: string}
     */
    function validateRequiredData(includedGameIds, weekMatchups) {
      const missingSpreads = [];
      
      const needsSpreads = showSpreads;
      const needsOverUnders = showOverUnder;
      
      if (!needsSpreads && !needsOverUnders) {
        return { isValid: true, message: '' };
      }

      includedGameIds.forEach(gameId => {
        const originalGame = weekMatchups.find(g => `${g.awayTeam}@${g.homeTeam}` === gameId);
        if (!originalGame) return;

        const currentSpread = editedSpreadData[gameId]?.spread ?? originalGame.spread;
        
        if (needsSpreads && !isValidSpread(currentSpread, originalGame.awayTeam, originalGame.homeTeam)) {
          missingSpreads.push(`${originalGame.awayTeam}@${originalGame.homeTeam}`);
        }
      });

      // Single Tiebreaker value validated
      let isOverUnderValid = true;
      if (needsOverUnders) {
        const tiebreakerInput = document.getElementById('tiebreaker-input');
        if (!tiebreakerInput || !isValidOverUnder(tiebreakerInput.value)) {
          isOverUnderValid = false;
        }
      }

      let errorMessage = '';
      if (missingSpreads.length > 0 || !isOverUnderValid) {
        errorMessage = '❌ ISSUE: DATA ISSUE!\n\n';
        if (missingSpreads.length > 0) {
          errorMessage += `Missing or invalid SPREADS for ${missingSpreads.length} game(s):\n${missingSpreads.join(', ')}\n\n`;
        }
        if (!isOverUnderValid) {
          errorMessage += `The final game's TIEBREAKER Over/Under value is missing or invalid.\n\n`;
        }
        errorMessage += 'Please fill in all required fields before creating the form.';
        return { isValid: false, message: errorMessage };
      }

      return { isValid: true, message: '' };
    }


    function onDataFetchFailure(error) {
      console.error('Error fetching member data:', error);
      alert('Could not load member data. Please try closing and reopening the panel.');
      hideLoader();
    }

    /**
     * Scrubs the editedSpreadData state object of any data that is no longer
     * relevant based on the current configuration (e.g., if ATS is turned off).
     */
    function scrubInvalidatedData() {
      const showSpreads = config.pickemsAts || config.survivorAts || config.eliminatorAts;

      // If both are visible, there's nothing to scrub.
      if (showSpreads) return;

      for (const gameId in editedSpreadData) {
        const edits = editedSpreadData[gameId];
        if (!showSpreads && edits.hasOwnProperty('spread')) {
          delete edits.spread;
        }
        if (Object.keys(edits).length === 0) {
          delete editedSpreadData[gameId];
        }
      }
    }

    /**
     * A single helper function that controls all visual
     * aspects of a row when it's enabled or disabled.
     *
     * @param {HTMLElement} row The <tr> element to modify.
     * @param {boolean} isEnabled The desired state (true for active, false for deselected).
     */
    function updateRowVisuals(row, isEnabled) {
      row.classList.toggle('deselected-row', !isEnabled);

      if (!isEnabled) {
        row.classList.remove('bonus-2x', 'bonus-3x');
      } else {
        const button = row.querySelector('.bonus-button');
        if (button) {
          const gameId = button.dataset.gameId;
          const currentMultiplier = bonusMultiplierState[gameId] || 1;
          row.classList.toggle('bonus-2x', currentMultiplier === 2);
          row.classList.toggle('bonus-3x', currentMultiplier === 3);
        }
        }
      
      const inputs = row.querySelectorAll('.spread-value-input');
      const teamBtns = row.querySelectorAll('.spread-team-btn');
      
      inputs.forEach(input => input.disabled = !isEnabled);
      teamBtns.forEach(btn => btn.style.pointerEvents = isEnabled ? 'auto' : 'none');
    }

    /**
     * Helper to get the current list of included games in their visible order.
     */
    function getIncludedGames() {
      const selectedWeek = document.getElementById('week-select').value;
      const selectionMode = document.querySelector('input[name="selectionMode"]:checked').value;
      const weekMatchups = allMatchups.filter(m => m.week == selectedWeek);
      let includedGameObjects = [];

      if (selectionMode === 'custom') {
        const orderedGameIds = Array.from(document.querySelectorAll('#matchup-table-body tr')).map(tr => tr.dataset.gameId);
        const includedIds = orderedGameIds.filter(gameId => selectionState.matchups[gameId] !== false);
        includedGameObjects = includedIds.map(id => weekMatchups.find(game => `${game.awayTeam}@${game.homeTeam}` === id)).filter(Boolean);
      } else {
        const gameIds = getIncludedGameIds(); // Use existing logic for other modes
        includedGameObjects = gameIds.map(id => weekMatchups.find(game => `${game.awayTeam}@${game.homeTeam}` === id)).filter(Boolean);
      }
      return includedGameObjects;
    }

    /**
     * Helper to get game IDs for non-custom modes.
     */
    function getIncludedGameIds() {
      const selectedWeek = document.getElementById('week-select').value;
      const selectionMode = document.querySelector('input[name="selectionMode"]:checked').value;
      const weekMatchups = allMatchups.filter(m => m.week == selectedWeek);
      let includedGameIds = [];

      if (selectionMode === 'all') {
        includedGameIds = weekMatchups.map(game => `${game.awayTeam}@${game.homeTeam}`);
      } else if (selectionMode === 'weekday') {
        const enabledDays = Object.keys(selectionState.weekdays).filter(day => selectionState.weekdays[day]);
        includedGameIds = weekMatchups
          .filter(game => enabledDays.includes(game.dayName))
          .map(game => `${game.awayTeam}@${game.homeTeam}`);
      } else if (selectionMode === 'matchup' || selectionMode === 'custom') { // Re-use for base filtering
        includedGameIds = Object.keys(selectionState.matchups)
          .filter(gameId => selectionState.matchups[gameId] && weekMatchups.some(g => `${g.awayTeam}@${g.homeTeam}` === gameId));
      }
      return includedGameIds;
    }

    /**  Gathers all user intent from the panel, builds a clean
     * "game plan" object, and sends it to the server for processing.
     */
    function handleSubmit() {
      showLoader(); // Show spinner on submit

      const selectedWeek = document.getElementById('week-select').value;
      const selectionMode = document.querySelector('input[name="selectionMode"]:checked').value;
      const weekMatchups = allMatchups.filter(m => m.week == selectedWeek);
      
      const includedGames = getIncludedGames();

      if (includedGames.length === 0) {
        alert('You must select at least one game to include in the form.');
        hideLoader();
        return;
      }

      const includedGameIds = includedGames.map(g => `${g.awayTeam}@${g.homeTeam}`);
      const validationResult = validateRequiredData(includedGameIds, weekMatchups);
      if (!validationResult.isValid) {
        hideLoader();
        alert(validationResult.message);
        return;
      }

      const formName = `${config.groupName} - Week ${selectedWeek} - ${config.year}`;
      const gamePlan = {
        week: selectedWeek,
        membershipLocked: config.membershipLocked,
        formName: formName,
        games: []
      }

      includedGames.forEach((originalGame, index) => {
        const gameId = `${originalGame.awayTeam}@${originalGame.homeTeam}`;
        let overUnderValue = editedSpreadData[gameId]?.overUnder ?? originalGame.overUnder;
        
        // MODIFICATION: Override the last game's O/U with the tiebreaker value
        if (showOverUnder && index === includedGames.length - 1) {
          overUnderValue = tiebreakerOverUnder;
        }

        gamePlan.games.push({
          date: originalGame.date,
          awayTeam: originalGame.awayTeam,
          homeTeam: originalGame.homeTeam,
          awayTeamLocation: originalGame.awayTeamLocation,
          awayTeamName: originalGame.awayTeamName,
          homeTeamLocation: originalGame.homeTeamLocation,
          homeTeamName: originalGame.homeTeamName,
          dayName: originalGame.dayName,
          hour: originalGame.hour,
          minute: originalGame.minute,
          type: originalGame.type,
          divisional: originalGame.divisional,
          division: originalGame.division,
          spread: editedSpreadData[gameId]?.spread ?? originalGame.spread,
          overUnder: overUnderValue,
          bonus: bonusMultiplierState[gameId] || 1
        });
      });

      gamePlan.edits = editedData;
      console.log("Submitting Game Plan:", gamePlan);

      google.script.run
        .withSuccessHandler(onSubmitSuccess)
        .withFailureHandler(onSubmitFailure)
        .createNewFormForWeek(gamePlan);
    }

    function onSubmitSuccess(response) {
      hideLoader();
      // Check if the server sent back the special "template opened" signal.
      if (response && response.status === 'TEMPLATE_OPENED') {
        // The server already showed the link dialog. The user's job here is done.
        // We just need to cleanly close this panel.
        console.log("Template opened. Closing form creator panel.");
        google.script.host.close();
        return; // Stop execution here.
      }
      
      // This is the normal success path for when a form is actually created.
      if (response && response.message) {
        alert(response.message);
      }
      google.script.host.close();
    }
    function onSubmitFailure(error) {
      hideLoader();
      
      // Check if the error message contains our special cancellation code.
      if (error && error.message.includes("CANCELLED_BY_USER")) {
        console.log("Form creation was cancelled by the user at a prompt.");
        google.script.run.showToast('Form creation cancelled.');
        google.script.host.close();
      } else {
        // This is a real, unexpected error. Show the full error message.
        alert('An unexpected error occurred: ' + (error ? error.message : 'Unknown error'));
      }
    }  
  </script>
</body>
</html>
